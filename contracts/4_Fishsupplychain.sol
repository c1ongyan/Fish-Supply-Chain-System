// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "./5_Fishrole.sol";
import "./7_Consumerole.sol";
import "./8_DistributorRole.sol";
import "./9_Retailerrole.sol";


// Define a contract 'Supplychain'
contract SupplyChain is
    Ownable,
    FisherRole,
    DistributorRole,
    RetailerRole,
    ConsumerRole,
    ERC20
{
    uint256 public constant WEI_PER_TOKEN = 100;

    uint256 public constant depositvalue = 10 ;

    // 铸造功能，仅限合约所有者
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    // 销毁功能，仅限合约所有者
    function burn(uint256 amount) external onlyOwner {
        _burn(msg.sender, amount);
    }

    // 修改后的购买功能，允许各个角色购买FishToken
    function buyTokens() public payable {
        require(msg.value > 0, "Must send some ether to buy tokens");
        uint256 tokenAmount = msg.value / WEI_PER_TOKEN;
        require(tokenAmount > 0, "Not enough ether to buy even one token");
        require(balanceOf(owner()) >= tokenAmount, "Not enough tokens available");

        // 检查调用者是否属于供应链中的有效角色（Fisher、Distributor、Retailer、Consumer）
        require(
            isFisher(msg.sender) ||
            isDistributor(msg.sender) ||
            isRetailer(msg.sender) ||
            isConsumer(msg.sender),
            "Caller is not a valid role in the supply chain"
        );

        // 将代币从所有者转移到购买者
        _transfer(owner(), msg.sender, tokenAmount);
       // emit TokensBought(msg.sender, tokenAmount);  // 触发购买代币事件，记录购买者和购买数量
    }

    // 提取合约中的以太币，仅限合约所有者
    function withdrawEther() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    // 覆写以支持小数点精度
    function decimals() public pure override returns (uint8) {
        return 2; // 100 wei = 1 FishToken
    }
    // Define 'owner'
    //address owner;


    // Define a variable called 'productCode' for Universal Product Code (productCode)
    uint256 productCode;

    // Define a variable called 'stockUnit' for Stock Keeping Unit (stockUnit)
    uint256 stockUnit;

    // Define a public mapping 'items' that maps the productCode to an Item.
    mapping(uint256 => Item) items;

    // Define a public mapping 'itemsHistory' that maps the productCode to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint256 => Txblocks) itemsHistory;

    // Define enum 'State' with the following values:
    enum State {
        ProduceByFisher, // 0
        ForSaleByFisher, // 1
        PurchasedByDistributor, // 2
        ShippedByFisher, // 3
        ReceivedByDistributor, // 4
        ProcessedByDistributor, // 5
        PackageByDistributor, // 6
        ForSaleByDistributor, // 7
        PurchasedByRetailer, // 8
        ShippedByDistributor, // 9
        ReceivedByRetailer, // 10
        ForSaleByRetailer, // 11
        PurchasedByConsumer // 12
    }

    State constant defaultState = State.ProduceByFisher;

    // Define a struct 'Item' with the following fields:
    struct Item {
        uint256 stockUnit; // Stock Keeping Unit (stockUnit)
        uint256 productCode; // Universal Product Code (productCode), generated by the Fisher, goes on the package, can be verified by the Consumer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address fisherID; // Metamask-Ethereum address of the Fisher // ADDED PAYABLE
        string fishName; // Fisher Name
        string fishInformation; // Fisher Information
        string fishTemperature; // Fish Temperature
        string fishSafe; // Fish Safe
        uint256 productID; // Product ID potentially a combination of productCode + stockUnit
        string productNotes; // Product Notes
        uint256 productDate; // Product Date NOTE: MIGHT NEED TO CHANGE type
        uint256 productPrice; // Product Price
        uint256 productSliced; // Parent product
        State itemState; // Product State as represented in the enum above
        address distributorID; // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        address consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
        uint256 depositAmount; // 商品对应的押金金额
        address depositPayer; // 支付该商品押金的地址（即出售方）
    }

    // Block number stuct
    struct Txblocks {
        uint256 FTD; // blockfisherToDistributor
        uint256 DTR; // blockDistributorToRetailer
        uint256 RTC; // blockRetailerToConsumer
    }

    event ProduceByFisher(uint256 productCode); //1
    event ForSaleByFisher(uint256 productCode); //2
    event PurchasedByDistributor(uint256 productCode); //3
    event ShippedByFisher(uint256 productCode); //4
    event ReceivedByDistributor(uint256 productCode); //5
    event ProcessedByDistributor(uint256 productCode); //6
    event PackagedByDistributor(uint256 productCode); //7
    event ForSaleByDistributor(uint256 productCode); //8
    event PurchasedByRetailer(uint256 productCode); //9
    event ShippedByDistributor(uint256 productCode); //10
    event ReceivedByRetailer(uint256 productCode); //11
    event ForSaleByRetailer(uint256 productCode); //12
    event PurchasedByConsumer(uint256 productCode); //13

    event DepositPaid(uint256 productCode, address payer, uint256 amount); // 通用的押金支付事件
    event DepositRefundedInToken(uint256 productCode, address depositPayer, uint256 amount);
    
    // Define a modifer that checks to see if _msgSender() == owner of the contract
    modifier only_Owner() {
        require(_msgSender() == Ownable.owner());
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller(address _address) {
        require(_msgSender() == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint256 _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint256 _productCode, address payable addressToFund) {
        uint256 _price = items[_productCode].productPrice;
        uint256 amountToReturn = msg.value - _price;
        addressToFund.transfer(amountToReturn);
        _;
    }

    //Item State Modifiers
    modifier producedByFisher(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProduceByFisher);
        _;
    }

    modifier forSaleByFisher(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByFisher);
        _;
    }

    modifier purchasedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByDistributor);
        _;
    }

    modifier shippedByFisher(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByFisher);
        _;
    }

    modifier receivedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByDistributor);
        _;
    }

    modifier processByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProcessedByDistributor);
        _;
    }

    modifier packagedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.PackageByDistributor);
        _;
    }

    modifier forSaleByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByDistributor);
        _;
    }

    modifier shippedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByDistributor);
        _;
    }

    modifier purchasedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByRetailer);
        _;
    }

    modifier receivedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByRetailer);
        _;
    }

    modifier forSaleByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByRetailer);
        _;
    }

    modifier purchasedByConsumer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByConsumer);
        _;
    }
    // 定义修饰器来检查押金是否已支付且支付者是否正确
    modifier depositPaidAndCorrectPayer(uint256 _productCode) {
        require(items[_productCode].depositAmount >= depositvalue && items[_productCode].depositPayer == _msgSender(), "Deposit not paid or incorrect payer");
        _;
    }


    constructor() ERC20("FishToken", "FISH") Ownable(msg.sender) {
        stockUnit = 1;
        productCode = 1;
        // 铸造初始供应量的代币，并将其分配给合约所有者
        _mint(msg.sender, 1000 * 10 ** decimals());

     }


    // Define a function 'kill'
    // function kill() public {
    //     require(_msgSender() == Ownable.owner());
    //     address actualOwner = Ownable.owner();
    //     address payable ownerAddressPayable = _make_payable(actualOwner);
    //     selfdestruct(ownerAddressPayable);

    // }

    // allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }



    /*
 1st step in supplychain
 Allows fisher to create product
 渔民创建产品
*/
    function produceItemByFisher(
        uint256 _productCode,
        string memory _fishName,
        string memory _fishInformation,
        string memory _fishTemperature,
        string memory _fishSafe,
        string memory _productNotes,
        uint256 _price
    )
        public
        onlyFisher // check address belongs to fisherRole
    {
        address distributorID; // Empty distributorID address
        address retailerID; // Empty retailerID address
        address consumerID; // Empty consumerID address
        Item memory newProduce; // Create a new struct Item in memory
        newProduce.stockUnit = stockUnit; // Stock Keeping Unit (stockUnit)
        newProduce.productCode = _productCode; // Universal Product Code (productCode), generated by the Fisher, goes on the package, can be verified by the Consumer
        newProduce.ownerID = _msgSender(); // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newProduce.fisherID = _msgSender(); // Metamask-Ethereum address of the Fisher
        newProduce.fishName = _fishName; // Fisher Name
        newProduce.fishInformation = _fishInformation; // Fisher Information
        newProduce.fishTemperature = _fishTemperature; // Fish Temperature
        newProduce.fishSafe = _fishSafe; // Fish Safe
        newProduce.productID = _productCode + stockUnit; // Product ID
        newProduce.productNotes = _productNotes; // Product Notes
        newProduce.productPrice = _price; // Product Price
        newProduce.productDate = block.timestamp;
        newProduce.productSliced = 0;
        newProduce.itemState = defaultState; // Product State as represented in the enum above
        newProduce.distributorID = distributorID; // Metamask-Ethereum address of the Distributor
        newProduce.retailerID = retailerID; // Metamask-Ethereum address of the Retailer
        newProduce.consumerID = consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
        items[_productCode] = newProduce; // Add newProduce to items struct by productCode
        uint256 placeholder; // Block number place holder
        Txblocks memory txBlock; // create new txBlock struct
        txBlock.FTD = placeholder; // assign placeholder values
        txBlock.DTR = placeholder;
        txBlock.RTC = placeholder;
        itemsHistory[_productCode] = txBlock; // add txBlock to itemsHistory mapping by productCode

        // Increment stockUnit
        stockUnit = stockUnit + 1;

        // Emit the appropriate event
        emit ProduceByFisher(_productCode);
    }

    /*
2nd step in supplychain
Allows fisher to sell product
设置商品为可售卖状态
*/
    function sellItemByFisher(uint256 _productCode, uint256 _price)
        public
        onlyFisher // check _msgSender() belongs to fisherRole
        producedByFisher(_productCode) // check items state has been produced
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
        depositPaidAndCorrectPayer(_productCode)
    {
        items[_productCode].itemState = State.ForSaleByFisher;
        items[_productCode].productPrice = _price;
        emit ForSaleByFisher(_productCode);
    }
    //支付押金 至少10fishtoken
    function payDeposit(uint256 _productCode, uint256 _depositAmount) 
        public 
        verifyCaller(items[_productCode].ownerID)
    {
        require(balanceOf(msg.sender) >= _depositAmount, "Not enough tokens to complete the purchase");
        transfer(address(this), _depositAmount);

        items[_productCode].depositAmount = _depositAmount;
        items[_productCode].depositPayer = _msgSender();

        emit DepositPaid(_productCode, _msgSender(), _depositAmount);
    }
    //  退还押金
    function refundDepositInToken(uint256 _productCode) public {
        Item storage item = items[_productCode];
        require(item.depositAmount > 0, "No deposit to refund");
        // 使用正确的方式检查合约持有的 FishToken 余额是否足够退还押金
        require(balanceOf(address(this)) >= item.depositAmount, "Contract token balance insufficient to refund deposit");
        // 改为使用 transferFrom 函数，从合约账户（已授权的情况下）将押金退还给支付押金的一方
        bool transferSuccess = transferFrom(address(this), item.depositPayer, item.depositAmount);
        require(transferSuccess, "Token transfer failed");
        item.depositAmount = 0;
        emit DepositRefundedInToken(_productCode, item.depositPayer, item.depositAmount);
    }

    /*
3rd step in supplychain
Allows distributor to purchase product
*/
    function purchaseItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to distributorRole
        forSaleByFisher(_productCode) // check items state is for ForSaleByFisher
    {
        uint256 price = items[_productCode].productPrice;
        require(balanceOf(msg.sender) >= price, "Not enough tokens to complete the purchase");
        // 将对应数量的 FishToken 从购买者（分销商）转移到销售者（渔民）
         transfer(items[_productCode].fisherID, price);

        items[_productCode].ownerID = msg.sender;
        items[_productCode].distributorID = msg.sender;
        items[_productCode].itemState = State.PurchasedByDistributor;
        itemsHistory[_productCode].FTD = block.number;
        emit PurchasedByDistributor(_productCode);
    }

    /*
  4th step in supplychain
  Allows fisher to ship product purchased by distributor
  */
    function shippedItemByFisher(uint256 _productCode)
        public
        payable
        onlyFisher // check _msgSender() belongs to FisherRole
        purchasedByDistributor(_productCode)
        verifyCaller(items[_productCode].fisherID) // check _msgSender() is originFishID
    {
        items[_productCode].itemState = State.ShippedByFisher; // update state
        emit ShippedByFisher(_productCode);
    }

    /*
  5th step in supplychain
  Allows distributor to receive product
  */
    function receivedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        shippedByFisher(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ReceivedByDistributor; // update state
        emit ReceivedByDistributor(_productCode);
        // 授权购买方（这里是分销商）可以从合约账户中转出对应押金金额的代币，假设当前调用者（分销商）就是后续要退还押金时操作的主体
        _approve(address(this), msg.sender, items[_productCode].depositAmount);
        // 然后调用退还押金函数
        refundDepositInToken(_productCode);
    }

    /*
  6th step in supplychain
  Allows distributor to process product
  */
    function processedItemByDistributor(uint256 _productCode, uint256 slices)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        receivedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ProcessedByDistributor; // update state
        items[_productCode].productSliced = slices; // add slice amount
        emit ProcessedByDistributor(_productCode);
    }

    /*
  7th step in supplychain
  Allows distributor to package product
  */
    function packageItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        processByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.PackageByDistributor;
        emit PackagedByDistributor(_productCode);
    }

    /*
  8th step in supplychain
  Allows distributor to sell product
  */
    function sellItemByDistributor(uint256 _productCode, uint256 _price)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        packagedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
        depositPaidAndCorrectPayer(_productCode)
    {
        items[_productCode].itemState = State.ForSaleByDistributor;
        items[_productCode].productPrice = _price;
        emit ForSaleByDistributor(productCode);
    }

    /*
  9th step in supplychain
  Allows retailer to purchase product
  */
    function purchaseItemByRetailer(uint256 _productCode)
        public
        onlyRetailer // 检查调用者是否属于零售商角色
        forSaleByDistributor(_productCode) // 检查商品是否处于分销商可售卖状态
    {
        uint256 price = items[_productCode].productPrice;
        require(balanceOf(msg.sender) >= price, "Not enough tokens to complete the purchase");
        // 直接使用继承自ERC20的transferFrom函数，将对应数量的FishToken从调用者（零售商）转移到当前商品的所有者（分销商）
        transfer(items[_productCode].distributorID, price); 

        items[_productCode].ownerID = msg.sender;
        items[_productCode].retailerID = msg.sender;
        items[_productCode].itemState = State.PurchasedByRetailer;
        itemsHistory[_productCode].DTR = block.number;
        emit PurchasedByRetailer(_productCode);
    }

    /*
  10th step in supplychain
  Allows Distributor to
  */
    function shippedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check _msgSender() belongs to DistributorRole
        purchasedByRetailer(_productCode)
        verifyCaller(items[_productCode].distributorID) // check _msgSender() is distributorID
    {
        items[_productCode].itemState = State.ShippedByDistributor;
        emit ShippedByDistributor(_productCode);
    }

    /*
  11th step in supplychain
  */
    function receivedItemByRetailer(uint256 _productCode)
        public
        onlyRetailer // check _msgSender() belongs to RetailerRole
        shippedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is ownerID
    {
        items[_productCode].itemState = State.ReceivedByRetailer;
        emit ReceivedByRetailer(_productCode);
        // 授权购买方（这里是分销商）可以从合约账户中转出对应押金金额的代币，假设当前调用者（分销商）就是后续要退还押金时操作的主体
        _approve(address(this), msg.sender, items[_productCode].depositAmount);
        // 然后调用退还押金函数
        refundDepositInToken(_productCode);
    }

    /*
  12th step in supplychain
  */
    function sellItemByRetailer(uint256 _productCode, uint256 _price)
        public
        onlyRetailer // check _msgSender() belongs to RetailerRole
        receivedByRetailer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is ownerID
    {
        items[_productCode].itemState = State.ForSaleByRetailer;
        items[_productCode].productPrice = _price;
        emit ForSaleByRetailer(_productCode);
    }


    /*
    13th step in supplychain
    Allows consumer to purchase product
    */
    function purchaseItemByConsumer(uint256 _productCode)
        public
        onlyConsumer // 检查调用者是否属于消费者角色
        forSaleByRetailer(_productCode) // 检查商品是否处于零售商可售卖状态
    {
        uint256 price = items[_productCode].productPrice;
        require(balanceOf(msg.sender) >= price, "Not enough tokens to complete the purchase");
        // 同样直接使用transferFrom函数，将对应数量的FishToken从调用者（消费者）转移到当前商品的所有者（零售商）
        transfer(items[_productCode].retailerID, price); 

        items[_productCode].consumerID = msg.sender;
        items[_productCode].ownerID = msg.sender;
        items[_productCode].itemState = State.PurchasedByConsumer;
        itemsHistory[_productCode].RTC = block.number;
        emit PurchasedByConsumer(_productCode);
    }

    // Define a function 'fetchItemBufferOne' that fetches the data
    function fetchItemBufferOne(uint256 _productCode)
        public
        view
        returns (
            uint256 itemstockUnit,
            uint256 itemproductCode,
            address ownerID,
            address fisherID,
            string memory fishName,
            string memory fishInformation,
            string memory fishTemperature,
            string memory fishSafe,
            uint256 productDate,
            uint256 productSliced
        )
    {
        // Assign values to the 8 parameters
        Item memory item = items[_productCode];

        return (
            item.stockUnit,
            item.productCode,
            item.ownerID,
            item.fisherID,
            item.fishName,
            item.fishInformation,
            item.fishTemperature,
            item.fishSafe,
            item.productDate,
            item.productSliced
        );
    }

    // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint256 _productCode)
        public
        view
        returns (
            uint256 itemstockUnit,
            uint256 itemproductCode,
            uint256 productID,
            string memory productNotes,
            uint256 productPrice,
            uint256 productDate,
            State itemState,
            address distributorID,
            address retailerID,
            address consumerID
        )
    {
        // Assign values to the 9 parameters
        Item memory item = items[_productCode];

        return (
            item.stockUnit,
            item.productCode,
            item.productID,
            item.productNotes,
            item.productPrice,
            item.productDate,
            item.itemState,
            item.distributorID,
            item.retailerID,
            item.consumerID
        );
    }

    // Define a function 'fetchItemHistory' that fetaches the data
    function fetchitemHistory(uint256 _productCode)
        public
        view
        returns (
            uint256 blockfisherToDistributor,
            uint256 blockDistributorToRetailer,
            uint256 blockRetailerToConsumer
        )
    {
        // Assign value to the parameters
        Txblocks memory txblock = itemsHistory[_productCode];
        return (txblock.FTD, txblock.DTR, txblock.RTC);
    }
}
